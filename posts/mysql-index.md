# MySQL 索引原理：为什么是 B+ 树而不是 B 树？

> 学习日期：2026-02-28 | 标签：MySQL, 数据库

## 一句话总结

索引就是**数据库的目录**，用 B+ 树而不是 B 树，是因为 B+ 树的叶子节点串成链表，**范围查询不需要回溯**，而且非叶子节点不存数据，同样大小的磁盘页能放更多指针，**树更矮、I/O 更少**。

## 为什么需要索引？

没有索引 = **全表扫描**。

假设你有 100 万条数据，每条 1KB，总共约 1GB：
- 无索引：最坏扫描全部 100 万条 → 几秒甚至几十秒
- 有 B+ 树索引：树高约 3 层 → **3 次磁盘 I/O** → 毫秒级

## B+ 树 vs B 树

```
B 树：
     [10 | 20]
    /    |     \
 [5]  [15]   [25,30]    ← 每个节点都存数据

B+ 树：
     [10 | 20]           ← 非叶子只存指针
    /    |     \
 [5]→[10,15]→[20,25,30]  ← 数据都在叶子，叶子串成链表
```

### 关键区别

| 特性 | B 树 | B+ 树 |
|------|------|-------|
| 数据存储 | 所有节点 | **只在叶子节点** |
| 叶子链表 | 无 | **有（双向链表）** |
| 范围查询 | 需要中序遍历 | **链表顺序扫描** ✅ |
| 非叶子容量 | 少（因为存了数据） | **多（只存指针）** |
| 树高 | 相对高 | **更矮** ✅ |

> 💡 核心结论：B+ 树在**范围查询**和**磁盘 I/O** 两个维度完胜 B 树，而数据库 80% 的查询都是范围查询（WHERE age > 20, ORDER BY, BETWEEN...）

## 聚簇索引 vs 非聚簇索引

```
聚簇索引（主键索引）：
叶子节点直接存【整行数据】
→ 每张表只能有一个
→ InnoDB 默认按主键组织数据

非聚簇索引（二级索引）：
叶子节点存【主键值】
→ 查到主键后还要【回表】查聚簇索引拿完整数据
```

### 什么是回表？

```sql
-- 假设 name 列有索引
SELECT * FROM user WHERE name = 'James';
```

执行过程：
1. 在 name 的 B+ 树中找到 `name = 'James'` 的叶子节点
2. 拿到对应的主键值（比如 id = 42）
3. **再去主键的 B+ 树查 id = 42 的完整行** ← 这就是回表

### 覆盖索引（避免回表）

```sql
-- 如果建了联合索引 (name, age)
SELECT name, age FROM user WHERE name = 'James';
-- 不需要回表！索引里已经有 name 和 age 了
```

## 索引失效的常见场景

```sql
-- ❌ 对索引列使用函数
WHERE YEAR(create_time) = 2026

-- ❌ 隐式类型转换
WHERE phone = 13800138000  -- phone 是 varchar

-- ❌ LIKE 左模糊
WHERE name LIKE '%James'

-- ❌ 联合索引不满足最左前缀
-- 索引 (a, b, c)，查询 WHERE b = 1  ← 用不上索引

-- ✅ 最左前缀匹配
WHERE a = 1              -- 用上 a
WHERE a = 1 AND b = 2    -- 用上 a, b
WHERE a = 1 AND b = 2 AND c = 3  -- 全用上
```

## 面试怎么答？

### 30 秒版本
"MySQL 用 B+ 树做索引，因为非叶子节点不存数据，一个磁盘页能放更多指针，树更矮 I/O 更少。叶子节点用链表串起来，范围查询直接顺序扫描。InnoDB 的聚簇索引叶子存完整行数据，二级索引叶子存主键值，查询时可能需要回表。"

### 追问：怎么优化慢查询？
"第一步 EXPLAIN 看执行计划，关注 type（最好到 ref 或 range）、key（是否用上索引）、Extra（是否 filesort 或 temporary）。常见优化：加合适的索引、避免 SELECT *、用覆盖索引减少回表、注意最左前缀原则。"

## 我的理解

索引的本质就是**用空间换时间**。这个设计哲学在很多地方都能看到：
- Redis 的跳表（有序集合的索引）
- 搜索引擎的倒排索引
- Agent 系统中的 **Semantic Cache**（用向量索引加速语义检索）

理解了 B+ 树，再学其他索引结构就是换皮了。
